<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Qaf Framework: Tutorial 5 - Iterators and Collision Handlers</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="tutorial05">Tutorial 5 - Iterators and Collision Handlers</a></h1>In <a class="el" href="tutorial04.html">Tutorial 4 - Spawn Points and Factories</a>, we created lots of mines floating around the ship, but we didn't do anything to make them collide.<p>
This tutorial will cover a few techniques you can use to make objects interact with each other.<h2><a class="anchor" name="tut05s01">
Homing Missiles</a></h2>
What if the missiles were smart enough to always target the closest mine? To do that, a <code>MissileObj</code> will need to examine all the <code>SpaceMineObj</code>s and pick the closest one to itself. This can be achieved by using an <em>object iterator</em> in <code>MissileObj::update()</code>:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define MISSILE_ANGSPEED     3.5f</span>
</pre></div> <div class="fragment"><pre class="fragment">        <span class="keywordtype">void</span> update ( <span class="keywordtype">int</span> objLayer, <span class="keywordtype">float</span> dt ) {
            <span class="comment">// Search the Environment for the closest space mine:</span>
            SpaceMineObj * pTargetMine = NULL;
            <span class="keywordtype">float</span> fTargetDist;
            
            ObjIterator&lt;SpaceMineObj&gt; it = Environment::makeObjIterator&lt;SpaceMineObj&gt;();
            <span class="keywordflow">while</span> ( it.hasNext() ) {
                SpaceMineObj * pMine = it.next();
                
                <span class="comment">// Calculate distance between the space mine and this missile:</span>
                <span class="keywordtype">float</span> fDist = (pMine-&gt;getPos() - m_pos).length();
                
                <span class="comment">// Have we found a shorter distance?</span>
                <span class="keywordflow">if</span> ( pTargetMine == NULL || fDist &lt; fTargetDist ) {
                    pTargetMine = pMine;
                    fTargetDist = fDist;
                }
            }
            
            <span class="comment">// We've found our target mine!</span>
            <span class="comment">// ...Or maybe not. If there are no mines left in the playfield,</span>
            <span class="comment">// then there's nothing to target.</span>
            <span class="keywordflow">if</span> ( pTargetMine != NULL ) {
                <span class="comment">// OK, we've got a target.</span>
                Vector2D vMissileToMine = pTargetMine-&gt;getPos() - m_pos;
                
                <span class="comment">// Rotate the missile's velocity so it will arc towards the mine.</span>
                <span class="keywordflow">if</span> ( m_vel.angle( vMissileToMine ) &lt; 0 )
                    <span class="comment">// Counter-clockwise:</span>
                    m_vel = m_vel.rotate( -MISSILE_ANGSPEED * dt );
                <span class="keywordflow">else</span>
                    <span class="comment">// Clockwise:</span>
                    m_vel = m_vel.rotate( MISSILE_ANGSPEED * dt );
            }
            
            ...
</pre></div><p>
With this code, missiles will always fly towards the mine that's closest to them. However, we still need to make them actually explode and destroy each other on contact.<h2><a class="anchor" name="tut05s02">
Collision Structures</a></h2>
In order to detect object-to-object collisions, each object will be assigned an instance of <code><a class="el" href="classqaf_1_1_collision_struct.html">qaf::CollisionStruct</a></code>. This is an abstract class; check out its documentation for a list of collision structure subclasses you can use. For this tutorial, we'll use <code><a class="el" href="classqaf_1_1_collision_struct_1_1_circle.html">qaf::CollisionStruct::Circle</a></code> and <code><a class="el" href="classqaf_1_1_collision_struct_1_1_polygon.html">qaf::CollisionStruct::Polygon</a></code>.<p>
Next, we need to associate collision structures with our objects. This is done with another method inherited from <code><a class="el" href="classqaf_1_1_game_obj.html">qaf::GameObj</a></code>:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classqaf_1_1_collision_struct.html">qaf::CollisionStruct</a> * <a class="code" href="classqaf_1_1_game_obj.html#c9d95a2b32f093e963cb628c7618d2b0">qaf::GameObj::getCollisionStruct</a> ();
</pre></div><p>
By default, <code>GameObj</code>'s implementation of this method returns <code>NULL</code> (which means "do not test this object for collisions"). To detect object-to-object collision, we're going to override this behavior in our classes and return a collision structure for each object.<p>
<b><code>SpaceMineObj</code>:</b> <br>
 This one is simple enough: Just initialize a circle in the constructor, and return it in <code>getCollisionStruct()</code>.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>SpaceMineObj : <span class="keyword">public</span> GameObj {
    <span class="keyword">private</span>:
        ...
        
        CollisionStruct::Circle m_circle; <span class="comment">// Collision boundaries</span>
        
    <span class="keyword">public</span>:
        SpaceMineObj ( Vector2D pos, <span class="keywordtype">float</span> size ) {
            ...
            
            <span class="comment">// Initialize collision structure:</span>
            m_circle.setXCenter( m_pos.x );
            m_circle.setYCenter( m_pos.y );
            m_circle.setRadius( m_size * m_sprite-&gt;GetWidth() / 2 );
        }
        
        CollisionStruct * getCollisionStruct () {
            <span class="keywordflow">return</span> &amp;m_circle;
        }
        
        ...
    };
</pre></div><p>
<b><code>MissileObj</code>:</b> <br>
 The missiles are constantly moving and rotating, so we can't simply initialize a bounding box in the constructor! Since the collision structure needs to be updated all the time, we'll add a bit of code to <code>update()</code>.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MissileObj : <span class="keyword">public</span> GameObj {
    <span class="keyword">private</span>:
        ...
        
        CollisionStruct::Polygon m_poly; <span class="comment">// Collision boundaries</span>
    
    <span class="keyword">public</span>:
        <span class="comment">// Constructor:</span>
        MissileObj ( Vector2D pos, Vector2D vel ) {
            ...
            
            <span class="comment">// Create a polygonal collision structure we can rotate along with</span>
            <span class="comment">// the sprite:</span>
            m_poly = CollisionStruct::Polygon( m_sprite );
            
            <span class="comment">// Initialize the polygon's position and rotation:</span>
            Vector2D vUp = Vector2D(0, -1);
            m_poly.setRotation( vUp.angle( m_vel ) );
            m_poly.setPosition( m_pos.x, m_pos.y );
        }
        
        CollisionStruct * getCollisionStruct () {
            <span class="keywordflow">return</span> &amp;m_poly;
        }
        
        ...
        
        <span class="keywordtype">void</span> update ( <span class="keywordtype">int</span> objLayer, <span class="keywordtype">float</span> dt ) {
            ...
            
            <span class="comment">// Update collision bounds:</span>
            Vector2D vUp = Vector2D(0, -1);
            m_poly.setRotation( vUp.angle( m_vel ) );
            m_poly.setPosition( m_pos.x, m_pos.y );
            
            ...
        }
        
        ...
};
</pre></div><p>
Almost there! Now that we've taken care of collision detection, it's time to implement collision response.<h2><a class="anchor" name="tut05s03">
The Collision Handler</a></h2>
This is just a callback function. It will be invoked when a collision occurs, and the two colliding objects will be passed as arguments to the function. We're interested in collisions between <code>MissileObj</code>s and <code>SpaceMineObj</code>s, so the declaration looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// The collision handler:</span>
<span class="keywordtype">void</span> handleCollision_Missile_SpaceMine ( MissileObj * pMissile, SpaceMineObj * pMine ) {
</pre></div><p>
I'm going to use a predefined class from the library (<code><a class="el" href="classqaf_1_1_anim_particle_obj.html">qaf::AnimParticleObj</a></code>) and an animation object (declared in <b>tut05sprites.txt</b>) to create an explosion at the space mine's position.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Create an explosion, by using one of Qaf's helper classes:</span>
    Environment::addGameObj(
        <span class="keyword">new</span> AnimParticleObj( 
            pResManager-&gt;GetAnimation( <span class="stringliteral">"aniExplosion"</span> ), <span class="comment">// anim</span>
            pMine-&gt;getPos().x, pMine-&gt;getPos().y, 0,     <span class="comment">// x, y, angle</span>
            0, 0, 0,                                     <span class="comment">// vx, vy, vr</span>
            0, 0,                                        <span class="comment">// ax, ay</span>
            pMine-&gt;getSize(), pMine-&gt;getSize() ) );      <span class="comment">// sizeX, sizeY</span>
</pre></div><p>
The mine and the missile will obliterate each other, so let's remove them from the playfield.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Remove both objects from the playfield and delete them:</span>
    Environment::removeGameObj( pMine, <span class="keyword">true</span> );
    Environment::removeGameObj( pMissile, <span class="keyword">true</span> );
}
</pre></div><p>
Finally, we <em>register</em> our handler. In <code>WinMain</code>:<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// "Hey, Qaf, this is what you should use to handle collisions between</span>
    <span class="comment">// Missiles and SpaceMines":</span>
    Environment::registerCollisionHandler&lt;MissileObj, SpaceMineObj&gt;( handleCollision_Missile_SpaceMine );   
</pre></div><p>
The syntax is a bit heavy there, so let's look at that line little by little.<ul>
<li><code><a class="el" href="classqaf_1_1_environment.html#720039cb11d774d4e316722320eb5bf3">qaf::Environment::registerCollisionHandler</a></code> is a template method. It accepts two <em>type parameters</em>.</li><li><b><code>&lt;MissileObj, SpaceMineObj&gt;</code></b> are the type parameters. Collision detection is class-based, so we actually tell Qaf the class, or <em>type</em>, of object that we want to handle.</li><li><b><code>handleCollision_Missile_SpaceMine</code></b> is a pointer to the function that should be called when a collision between a <code>MissileObj</code> and a <code>SpaceMineObj</code> is detected.</li></ul>
<p>
That's it!<p>
If you run the executable, you'll see a couple of extra touches:<ul>
<li>I added an option to render the collision structs' outlines by pressing "D". This is done via <code><a class="el" href="classqaf_1_1_collision_struct.html#3aaa4405b200f95a8edd61f492fd734a">qaf::CollisionStruct::render()</a></code> in the objects' <code>render()</code> method.</li><li>You can reload the room by pressing "R". This is a simple call to <code><a class="el" href="classqaf_1_1_environment.html#e9a325fc88c780829fcea654e9c54c61">qaf::Environment::loadRoom()</a></code> in the frame function.</li></ul>
<p>
See the full source code for this tutorial in the file: <b>tutorials/tutorial05.cpp</b> <hr size="1"><address style="align: right;"><small>Generated on Sun Mar 25 12:32:13 2007 for Qaf Framework by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
