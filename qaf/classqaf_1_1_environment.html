<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Qaf Framework: qaf::Environment Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceqaf.html">qaf</a>::<a class="el" href="classqaf_1_1_environment.html">Environment</a></div>
<h1>qaf::Environment Class Reference</h1><!-- doxytag: class="qaf::Environment" --><code>#include &lt;<a class="el" href="qaf_environment_8h-source.html">qafEnvironment.h</a>&gt;</code>
<p>
<a href="classqaf_1_1_environment-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> manages the game's state -- both static (window, loaded room, background layers), and dynamic (<code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s). 
<p>
Setting up the Qaf environment involves the following steps:<ul>
<li>Invoking the <code><a class="el" href="classqaf_1_1_environment.html#486076b9a3025256bfa2886c4eca34dd">initialize()</a></code> method to prepare the environment resources;</li><li>Defining a <code><a class="el" href="classqaf_1_1_game_obj_factory.html">GameObjFactory</a></code> by invoking the <code><a class="el" href="classqaf_1_1_environment.html#08cff5f41c59986ca96b7658ac73ed06">setGameObjFactory()</a></code> method;</li><li>Defining prologue and epilogue callbacks with <code><a class="el" href="classqaf_1_1_environment.html#b4480061701fa0fdfff8c5021ccb89ac">setPrologueCallback()</a></code> and <code><a class="el" href="classqaf_1_1_environment.html#ed4f9e03a1a1e070fd79f48a654f7a09">setEpilogueCallback()</a></code>;</li><li>Loading a starting room with <code><a class="el" href="classqaf_1_1_environment.html#e9a325fc88c780829fcea654e9c54c61">loadRoom()</a></code>;</li><li>Invoking the <code><a class="el" href="classqaf_1_1_environment.html#bad0c6b9a7110806673e639aeff788d9">update()</a></code> method in HGE's frame function.</li></ul>
<p>
Before shutting down HGE, you should invoke <code><a class="el" href="classqaf_1_1_environment.html#f5064b9177642d38eafe8bd65f5af025">Environment::shutdown()</a></code> to ensure everything is cleaned up before the application exits. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#486076b9a3025256bfa2886c4eca34dd">initialize</a> (bool useBackBuffer, bool useDebug)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This must be called before any other method, as it prepares the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>'s internal variables.  <a href="#486076b9a3025256bfa2886c4eca34dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#bad0c6b9a7110806673e639aeff788d9">update</a> (float dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this once per frame to perform Qaf's game loop.  <a href="#bad0c6b9a7110806673e639aeff788d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#572d9c6360994a53459ea63ac8a5aa6f">enableObjUpdate</a> (bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is a quick shortcut to turn on or off the execution of all <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s' <code>update()</code> method and collision detection.  <a href="#572d9c6360994a53459ea63ac8a5aa6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#76f4d266b06b2e396bf13b28b2f22182">isObjUpdateEnabled</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>true if object updating is enabled. </dd></dl>
 <a href="#76f4d266b06b2e396bf13b28b2f22182"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#96524fe4a3bc658312162767cbfc55c3">enableRender</a> (bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is a quick shortcut to turn on or off the execution of the <code>render()</code> method.  <a href="#96524fe4a3bc658312162767cbfc55c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#03800f84dbec528206beff5b4feff07c">isRenderEnabled</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>true if rendering is enabled. </dd></dl>
 <a href="#03800f84dbec528206beff5b4feff07c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#f5064b9177642d38eafe8bd65f5af025">shutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases all resources used by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>.  <a href="#f5064b9177642d38eafe8bd65f5af025"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#5e9628363cf4ae1d2cc9a4790fbb8a32">enableBackBuffer</a> (bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The back buffer is a render target used to store all rendered data before it is flushed to the screen.  <a href="#5e9628363cf4ae1d2cc9a4790fbb8a32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#35425bdb63d20eb90a621f1d002fde6a">isBackBufferEnabled</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the back buffer has been enabled (that does not mean that is has been successfully created, however). </dd></dl>
 <a href="#35425bdb63d20eb90a621f1d002fde6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#b7a59929d5c7c08e6e8e1f848d59fc3a">getBackBuffer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The back buffer's texture handle (HTEXTURE). </dd></dl>
 <a href="#b7a59929d5c7c08e6e8e1f848d59fc3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#08cff5f41c59986ca96b7658ac73ed06">setGameObjFactory</a> (<a class="el" href="classqaf_1_1_game_obj_factory.html">GameObjFactory</a> *_gameObjFactory)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When a room is loaded, the game object factory is queried by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> to create its objects.  <a href="#08cff5f41c59986ca96b7658ac73ed06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classqaf_1_1_game_obj_factory.html">GameObjFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#95ddee393ad89aed1cf0e4f461ad8a44">getGameObjFactory</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The game object factory currently in use by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>. </dd></dl>
 <a href="#95ddee393ad89aed1cf0e4f461ad8a44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#b4480061701fa0fdfff8c5021ccb89ac">setPrologueCallback</a> (void(*cb)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The prologue callback is called at the beginning of every frame cycle.  <a href="#b4480061701fa0fdfff8c5021ccb89ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#ed4f9e03a1a1e070fd79f48a654f7a09">setEpilogueCallback</a> (void(*cb)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The epilogue callback is called at the end of every frame cycle.  <a href="#ed4f9e03a1a1e070fd79f48a654f7a09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#e9a325fc88c780829fcea654e9c54c61">loadRoom</a> (std::string filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the game's loaded <code><a class="el" href="classqaf_1_1_room.html">Room</a></code>, unloading what was loaded before.  <a href="#e9a325fc88c780829fcea654e9c54c61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dda4f0cc57f8a108606059014810f419"></a><!-- doxytag: member="qaf::Environment::getLoadedRoom" ref="dda4f0cc57f8a108606059014810f419" args="()" -->
static <a class="el" href="classqaf_1_1_room.html">Room</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#dda4f0cc57f8a108606059014810f419">getLoadedRoom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the currently loaded <code><a class="el" href="classqaf_1_1_room.html">Room</a></code>, or <code>NULL</code> if no room has been loaded. </dd></dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#cc7e4323d401498c7db6928aa56c05e0">unloadRoom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unloads the currently loaded room, deleting all volatile <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s.  <a href="#cc7e4323d401498c7db6928aa56c05e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#97a4eb988f6bc8f3f370229ad1d1f9ee">setScrollingPoint</a> (int x, int y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This changes the "scrolling point," which represents the screen's displacement relative to the room's top-left corner.  <a href="#97a4eb988f6bc8f3f370229ad1d1f9ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#0b773de9d862371dea5470a0e3b9019b">moveScrollingPoint</a> (int dx, int dy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>How many pixels the screen should be "nudged" horizontally </td></tr>
  </table>
</dl>
 <a href="#0b773de9d862371dea5470a0e3b9019b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#67d98fc53fe831ba74b9e923fe9164af">centerScrollingPoint</a> (int x, int y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Centers the screen at coordinates (<code>x</code>, <code>y</code>).  <a href="#67d98fc53fe831ba74b9e923fe9164af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#49a9efb0ba36ca53f7a251507fd37531">getScrollingX</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The scrolling point's X coordinate. </dd></dl>
 <a href="#49a9efb0ba36ca53f7a251507fd37531"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#c12106c8e4aaf785adacd2865c0d4dfe">getScrollingY</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The scrolling point's Y coordinate. </dd></dl>
 <a href="#c12106c8e4aaf785adacd2865c0d4dfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#73b14d913c88eade58baa23ef18f7285">getScreenWidth</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current screen width.  <a href="#73b14d913c88eade58baa23ef18f7285"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#f0b6ef6c1581b52db3088fe759969c0b">getScreenHeight</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current screen height.  <a href="#f0b6ef6c1581b52db3088fe759969c0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#06ab1091a54083d7d2f884a608a1d9c1">addGameObj</a> (<a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *obj, int layer=-1, bool onTop=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts an object into the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>.  <a href="#06ab1091a54083d7d2f884a608a1d9c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#4a5e29e36163f3b53adc01dbb832ce9e">findGameObj</a> (<a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *obj, int *index=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> for the specified object.  <a href="#4a5e29e36163f3b53adc01dbb832ce9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#8fa0a2e6fea2a7f1c9c88164818eda26">removeGameObj</a> (<a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *obj, bool deleteIt, int srcLayer=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> for the specified <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code> and removes it from its current layer.  <a href="#8fa0a2e6fea2a7f1c9c88164818eda26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#5f90f160ccab9952a6f4093a881728cc">moveGameObj</a> (<a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *obj, int destLayer, int srcLayer=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> for the specified <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>, removes it from its current layer and places it into the destination layer.  <a href="#5f90f160ccab9952a6f4093a881728cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#7bff52cbed5afedd9369de89ef1c2b1a">bringGameObjToFront</a> (<a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *obj, int srcLayer=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Brings the object to the front of its layer.  <a href="#7bff52cbed5afedd9369de89ef1c2b1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#5806ba08a266344d6ca59a064ba70bfa">sendGameObjToBack</a> (<a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *obj, int srcLayer=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the object to the back of its layer.  <a href="#5806ba08a266344d6ca59a064ba70bfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#6c9ae9c8bb980fd4d53ba50924a8e371">getNumberOfJoysticks</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of joysticks that are currently available. </dd></dl>
 <a href="#6c9ae9c8bb980fd4d53ba50924a8e371"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classqaf_1_1_joystick.html">Joystick</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#9ea649952f5347b7a83e7b84ecd05091">getJoystick</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <code><a class="el" href="classqaf_1_1_joystick.html">Joystick</a></code> device available at index <code>i</code>, or <code>NULL</code> if an invalid index is specified. </dd></dl>
 <a href="#9ea649952f5347b7a83e7b84ecd05091"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#e4e3e2723c52ffee3792299de9c93fbf">loadBigTexture</a> (const char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a <code><a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a></code> from a file on the disk.  <a href="#e4e3e2723c52ffee3792299de9c93fbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#f245b7efc1bad945a935bfbe8d5981c8">freeBigTexture</a> (const <a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a> *tex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases an allocated <code><a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a></code>.  <a href="#f245b7efc1bad945a935bfbe8d5981c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#353307336567f728fd84cb0474f35385">setBigTextureCacheSize</a> (int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coordinates the <code><a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a></code> cache management.  <a href="#353307336567f728fd84cb0474f35385"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static <a class="el" href="classqaf_1_1_obj_iterator.html">ObjIterator</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#e2def878a51909ef17e4573b6394d26a">makeObjIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows clients to traverse the active object list.  <a href="#e2def878a51909ef17e4573b6394d26a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#720039cb11d774d4e316722320eb5bf3">registerCollisionHandler</a> (void(*pfHandler)(T1 *, T2 *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a collision handler between classes of objects.  <a href="#720039cb11d774d4e316722320eb5bf3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#62d38ac3354cb61971c5abe88509e8bc">time</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A "clock" used by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> to update the water level's undulation, current, and refraction.  <a href="#62d38ac3354cb61971c5abe88509e8bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb29841b88ecd62213a85570b1c851f5"></a><!-- doxytag: member="qaf::Environment::frames" ref="fb29841b88ecd62213a85570b1c851f5" args="" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#fb29841b88ecd62213a85570b1c851f5">frames</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <code>time</code>, this will keep track of how many frames were rendered. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12441f1ee5a7f944da1748fb29b21907"></a><!-- doxytag: member="qaf::Environment::cout" ref="12441f1ee5a7f944da1748fb29b21907" args="" -->
static <a class="el" href="classqaf_1_1_environment_1_1_debug_console.html">DebugConsole</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>cout</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classqaf_1_1_container.html">Container</a>&lt; <a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment.html#70e73860c328e85b995513f3df534cb8">debugVectors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add <code><a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a></code>s here.  <a href="#70e73860c328e85b995513f3df534cb8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>AbstractCollisionHandler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>AbstractObjDiscriminator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>CollisionHandler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqaf_1_1_environment_1_1_debug_console.html">DebugConsole</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The debug console is useful for outputting data to the screen.  <a href="classqaf_1_1_environment_1_1_debug_console.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ObjDiscriminator</b></td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="486076b9a3025256bfa2886c4eca34dd"></a><!-- doxytag: member="qaf::Environment::initialize" ref="486076b9a3025256bfa2886c4eca34dd" args="(bool useBackBuffer, bool useDebug)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool qaf::Environment::initialize           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useBackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useDebug</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This must be called before any other method, as it prepares the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>'s internal variables. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>useBackBuffer</em>&nbsp;</td><td>Whether the game should use a buffer before flushing to the screen. See <code><a class="el" href="classqaf_1_1_environment.html#5e9628363cf4ae1d2cc9a4790fbb8a32">enableBackBuffer()</a></code> for details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useDebug</em>&nbsp;</td><td>Passing true here will enable the <code><a class="el" href="classqaf_1_1_environment_1_1_debug_console.html">DebugConsole</a></code> and <code><a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a></code>s. The debug resources incur a slight overhead, so you might want to disable them for the game's final version.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false if there was a problem during initialization. Use <code>hge-&gt;System_GetErrorMessage()</code> to get a description of the error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bad0c6b9a7110806673e639aeff788d9"></a><!-- doxytag: member="qaf::Environment::update" ref="bad0c6b9a7110806673e639aeff788d9" args="(float dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::update           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>dt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this once per frame to perform Qaf's game loop. 
<p>
This will check collisions, update the <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s, perform all rendering operations, and call the prologue/epilogue functions.<p>
Usually, you will place this in HGE's frame function. 
</div>
</div><p>
<a class="anchor" name="572d9c6360994a53459ea63ac8a5aa6f"></a><!-- doxytag: member="qaf::Environment::enableObjUpdate" ref="572d9c6360994a53459ea63ac8a5aa6f" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::enableObjUpdate           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is a quick shortcut to turn on or off the execution of all <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s' <code>update()</code> method and collision detection. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_game_obj.html#0af4acfb62a29ae1ba37ffd5ce23a5d4">GameObj::update()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="76f4d266b06b2e396bf13b28b2f22182"></a><!-- doxytag: member="qaf::Environment::isObjUpdateEnabled" ref="76f4d266b06b2e396bf13b28b2f22182" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool qaf::Environment::isObjUpdateEnabled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if object updating is enabled. </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#572d9c6360994a53459ea63ac8a5aa6f">enableObjUpdate()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="96524fe4a3bc658312162767cbfc55c3"></a><!-- doxytag: member="qaf::Environment::enableRender" ref="96524fe4a3bc658312162767cbfc55c3" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::enableRender           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is a quick shortcut to turn on or off the execution of the <code>render()</code> method. 
<p>
In short, setting this flag to false will halt <em>all</em> rendering operations (both <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>- and <code><a class="el" href="classqaf_1_1_b_g_layer.html">BGLayer</a></code>-related), and the only rendering that could possibly take place would be in the prologue/epilogue callbacks.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_game_obj.html#ebd3555d614f244347f761372541602a">GameObj::render()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="03800f84dbec528206beff5b4feff07c"></a><!-- doxytag: member="qaf::Environment::isRenderEnabled" ref="03800f84dbec528206beff5b4feff07c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool qaf::Environment::isRenderEnabled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if rendering is enabled. </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#96524fe4a3bc658312162767cbfc55c3">enableRender()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5064b9177642d38eafe8bd65f5af025"></a><!-- doxytag: member="qaf::Environment::shutdown" ref="f5064b9177642d38eafe8bd65f5af025" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::shutdown           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases all resources used by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>. 
<p>
This method unloads textures, the loaded room, and <code>delete</code>s any <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s still active.<p>
This method should only be invoked after stopping HGE's game loop (i.e., when <code>System_Start()</code> returns), and not during game execution.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#486076b9a3025256bfa2886c4eca34dd">initialize()</a>, <a class="el" href="classqaf_1_1_environment.html#bad0c6b9a7110806673e639aeff788d9">update()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e9628363cf4ae1d2cc9a4790fbb8a32"></a><!-- doxytag: member="qaf::Environment::enableBackBuffer" ref="5e9628363cf4ae1d2cc9a4790fbb8a32" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::enableBackBuffer           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The back buffer is a render target used to store all rendered data before it is flushed to the screen. 
<p>
This buffer is necessary for the underwater distortion effect, and may be used by the developer to create sophisticated visual effects.<p>
The back buffer's dimensions are limited by the video card's maximum texture size; also, transferring data from this buffer to the screen may incur a heavy performance penalty. Thus, it is possible to disable the back buffer if performance or compatibility issues require it.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#35425bdb63d20eb90a621f1d002fde6a">isBackBufferEnabled()</a>, <a class="el" href="classqaf_1_1_environment.html#b7a59929d5c7c08e6e8e1f848d59fc3a">getBackBuffer()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="35425bdb63d20eb90a621f1d002fde6a"></a><!-- doxytag: member="qaf::Environment::isBackBufferEnabled" ref="35425bdb63d20eb90a621f1d002fde6a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool qaf::Environment::isBackBufferEnabled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the back buffer has been enabled (that does not mean that is has been successfully created, however). </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#5e9628363cf4ae1d2cc9a4790fbb8a32">enableBackBuffer()</a>, <a class="el" href="classqaf_1_1_environment.html#b7a59929d5c7c08e6e8e1f848d59fc3a">getBackBuffer()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7a59929d5c7c08e6e8e1f848d59fc3a"></a><!-- doxytag: member="qaf::Environment::getBackBuffer" ref="b7a59929d5c7c08e6e8e1f848d59fc3a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long qaf::Environment::getBackBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The back buffer's texture handle (HTEXTURE). </dd></dl>

<p>
This texture stores the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>'s rendered data (background layers and <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s). If the back buffer has been disabled or could not be created, returns <code>NULL</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#5e9628363cf4ae1d2cc9a4790fbb8a32">enableBackBuffer()</a>, <a class="el" href="classqaf_1_1_environment.html#35425bdb63d20eb90a621f1d002fde6a">isBackBufferEnabled()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="08cff5f41c59986ca96b7658ac73ed06"></a><!-- doxytag: member="qaf::Environment::setGameObjFactory" ref="08cff5f41c59986ca96b7658ac73ed06" args="(GameObjFactory *_gameObjFactory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::setGameObjFactory           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqaf_1_1_game_obj_factory.html">GameObjFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>_gameObjFactory</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When a room is loaded, the game object factory is queried by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> to create its objects. 
<p>
Setting this pointer to <code>NULL</code> will turn off object creation. 
</div>
</div><p>
<a class="anchor" name="95ddee393ad89aed1cf0e4f461ad8a44"></a><!-- doxytag: member="qaf::Environment::getGameObjFactory" ref="95ddee393ad89aed1cf0e4f461ad8a44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classqaf_1_1_game_obj_factory.html">GameObjFactory</a>* qaf::Environment::getGameObjFactory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The game object factory currently in use by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>. </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#08cff5f41c59986ca96b7658ac73ed06">setGameObjFactory()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b4480061701fa0fdfff8c5021ccb89ac"></a><!-- doxytag: member="qaf::Environment::setPrologueCallback" ref="b4480061701fa0fdfff8c5021ccb89ac" args="(void(*cb)())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::setPrologueCallback           </td>
          <td>(</td>
          <td class="paramtype">void(*)()&nbsp;</td>
          <td class="paramname"> <em>cb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The prologue callback is called at the beginning of every frame cycle. 
<p>
Its prototype must be:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> prologueCB ();
</pre></div><p>
It will be called each frame, <em>after</em> rendering starts (i.e., after <code>hge-&gt;Gfx_BeginScene()</code>). Anything rendered here will appear beneath all BG layers and game objects. If you need to clear the screen or apply scene-wide transformations, do those in the prologue function.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#ed4f9e03a1a1e070fd79f48a654f7a09">setEpilogueCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed4f9e03a1a1e070fd79f48a654f7a09"></a><!-- doxytag: member="qaf::Environment::setEpilogueCallback" ref="ed4f9e03a1a1e070fd79f48a654f7a09" args="(void(*cb)())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::setEpilogueCallback           </td>
          <td>(</td>
          <td class="paramtype">void(*)()&nbsp;</td>
          <td class="paramname"> <em>cb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The epilogue callback is called at the end of every frame cycle. 
<p>
Its prototype must be:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> epilogueCB ();
</pre></div><p>
It will be called after all rendering has been performed in each frame, but before <code>hge-&gt;Gfx_EndScene()</code>. Thus, it is safe to perform rendering operations here. They will appear in front of everything else; this is a good place to render on-screen status bars, menus, etc.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#b4480061701fa0fdfff8c5021ccb89ac">setPrologueCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e9a325fc88c780829fcea654e9c54c61"></a><!-- doxytag: member="qaf::Environment::loadRoom" ref="e9a325fc88c780829fcea654e9c54c61" args="(std::string filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool qaf::Environment::loadRoom           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes the game's loaded <code><a class="el" href="classqaf_1_1_room.html">Room</a></code>, unloading what was loaded before. 
<p>
The file must be a valid encoded room file, created with Qaf's Room Editor. If an error is found, the method returns false and the environment is left unchanged.<p>
Loading a room will automatically trigger the <code><a class="el" href="classqaf_1_1_environment.html#cc7e4323d401498c7db6928aa56c05e0">unloadRoom()</a></code> method; thus, all volatile <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s will be <code>delete</code>d. The new room's objects are extracted from the room file, and their data is forwarded to the current <code><a class="el" href="classqaf_1_1_game_obj_factory.html">GameObjFactory</a></code>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false if the file could not be loaded or it is not a valid Qaf room file.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This operation is not executed immediately. It will be kept in a buffer, and the actual loading will only take place at the end of the frame cycle.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#cc7e4323d401498c7db6928aa56c05e0">unloadRoom()</a>, <a class="el" href="classqaf_1_1_environment.html#08cff5f41c59986ca96b7658ac73ed06">setGameObjFactory()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc7e4323d401498c7db6928aa56c05e0"></a><!-- doxytag: member="qaf::Environment::unloadRoom" ref="cc7e4323d401498c7db6928aa56c05e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::unloadRoom           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unloads the currently loaded room, deleting all volatile <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>s. 
<p>
At the end of the operation, the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> will contain a single empty object layer.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This operation is not executed immediately. It will be kept in a buffer, and the actual unloading will only take place in the next frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#e9a325fc88c780829fcea654e9c54c61">loadRoom()</a>, <a class="el" href="classqaf_1_1_game_obj.html#71cc24179e83daadcc59b9d0a586cc52">GameObj::isVolatile()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="97a4eb988f6bc8f3f370229ad1d1f9ee"></a><!-- doxytag: member="qaf::Environment::setScrollingPoint" ref="97a4eb988f6bc8f3f370229ad1d1f9ee" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::setScrollingPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This changes the "scrolling point," which represents the screen's displacement relative to the room's top-left corner. 
<p>
The method will automatically clamp the coordinates, preventing the screen from "exiting" the loaded room's area.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#0b773de9d862371dea5470a0e3b9019b">moveScrollingPoint()</a>, <a class="el" href="classqaf_1_1_environment.html#67d98fc53fe831ba74b9e923fe9164af">centerScrollingPoint()</a>, <a class="el" href="classqaf_1_1_environment.html#49a9efb0ba36ca53f7a251507fd37531">getScrollingX()</a>, <a class="el" href="classqaf_1_1_environment.html#c12106c8e4aaf785adacd2865c0d4dfe">getScrollingY()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0b773de9d862371dea5470a0e3b9019b"></a><!-- doxytag: member="qaf::Environment::moveScrollingPoint" ref="0b773de9d862371dea5470a0e3b9019b" args="(int dx, int dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::moveScrollingPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>How many pixels the screen should be "nudged" horizontally </td></tr>
  </table>
</dl>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>How many pixels the screen should be "nudged" vertically</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#97a4eb988f6bc8f3f370229ad1d1f9ee">setScrollingPoint()</a>, <a class="el" href="classqaf_1_1_environment.html#67d98fc53fe831ba74b9e923fe9164af">centerScrollingPoint()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="67d98fc53fe831ba74b9e923fe9164af"></a><!-- doxytag: member="qaf::Environment::centerScrollingPoint" ref="67d98fc53fe831ba74b9e923fe9164af" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::centerScrollingPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Centers the screen at coordinates (<code>x</code>, <code>y</code>). 
<p>
This is the same as calling<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classqaf_1_1_environment.html#97a4eb988f6bc8f3f370229ad1d1f9ee">setScrollingPoint</a>( x - screenWidth/2, y - screenHeight/2 );
</pre></div><p>
where <code>screenWidth</code> and <code>screenHeight</code> are extracted from the currently loaded room.<p>
This method does nothing if there is no loaded room.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#97a4eb988f6bc8f3f370229ad1d1f9ee">setScrollingPoint()</a>, <a class="el" href="classqaf_1_1_environment.html#0b773de9d862371dea5470a0e3b9019b">moveScrollingPoint()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="49a9efb0ba36ca53f7a251507fd37531"></a><!-- doxytag: member="qaf::Environment::getScrollingX" ref="49a9efb0ba36ca53f7a251507fd37531" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int qaf::Environment::getScrollingX           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The scrolling point's X coordinate. </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#97a4eb988f6bc8f3f370229ad1d1f9ee">setScrollingPoint()</a>, <a class="el" href="classqaf_1_1_environment.html#c12106c8e4aaf785adacd2865c0d4dfe">getScrollingY()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c12106c8e4aaf785adacd2865c0d4dfe"></a><!-- doxytag: member="qaf::Environment::getScrollingY" ref="c12106c8e4aaf785adacd2865c0d4dfe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int qaf::Environment::getScrollingY           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The scrolling point's Y coordinate. </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#97a4eb988f6bc8f3f370229ad1d1f9ee">setScrollingPoint()</a>, <a class="el" href="classqaf_1_1_environment.html#49a9efb0ba36ca53f7a251507fd37531">getScrollingX()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="73b14d913c88eade58baa23ef18f7285"></a><!-- doxytag: member="qaf::Environment::getScreenWidth" ref="73b14d913c88eade58baa23ef18f7285" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int qaf::Environment::getScreenWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current screen width. 
<p>
If there is a loaded room, the room's screen width (in pixels) is returned. Otherwise, the window's screen width is returned by consulting the HGE_SCREENWIDTH system state. 
</div>
</div><p>
<a class="anchor" name="f0b6ef6c1581b52db3088fe759969c0b"></a><!-- doxytag: member="qaf::Environment::getScreenHeight" ref="f0b6ef6c1581b52db3088fe759969c0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int qaf::Environment::getScreenHeight           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current screen height. 
<p>
If there is a loaded room, the room's screen height (in pixels) is returned. Otherwise, the window's screen height is returned by consulting the HGE_SCREENHEIGHT system state. 
</div>
</div><p>
<a class="anchor" name="06ab1091a54083d7d2f884a608a1d9c1"></a><!-- doxytag: member="qaf::Environment::addGameObj" ref="06ab1091a54083d7d2f884a608a1d9c1" args="(GameObj *obj, int layer=-1, bool onTop=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::addGameObj           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>layer</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onTop</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts an object into the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code>. 
<p>
If no layer is specified, the loaded room's default layer is used.<p>
If <code>onTop</code> is true, the object will be inserted at the frontmost position in the layer.<p>
This operation is buffered, and its effects will only be visible in the next frame.<p>
The object's <code>initialize()</code> method will <em>not</em> be called.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_room.html#097821afc5f4921c68cadf7f1935308e">Room::defaultObjLayer</a>, <a class="el" href="classqaf_1_1_environment.html#8fa0a2e6fea2a7f1c9c88164818eda26">removeGameObj()</a>, <a class="el" href="classqaf_1_1_environment.html#5f90f160ccab9952a6f4093a881728cc">moveGameObj()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a5e29e36163f3b53adc01dbb832ce9e"></a><!-- doxytag: member="qaf::Environment::findGameObj" ref="4a5e29e36163f3b53adc01dbb832ce9e" args="(GameObj *obj, int *index=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int qaf::Environment::findGameObj           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> for the specified object. 
<p>
If it is found, this method returns its layer, and stores the object's index in the <code>index</code> pointer. (Keep in mind that each layer is a list of objects; objects that are at the front of the layer will have lower indices, and objects that are at the back will have higher indices.)<p>
If the object is not found, the method returns -1, and the <code>index</code> pointer is left unchanged.<p>
If you don't care about the object's intra-layer position, use <code>index = NULL</code>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The layer where the object currently resides, or -1 if the object is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8fa0a2e6fea2a7f1c9c88164818eda26"></a><!-- doxytag: member="qaf::Environment::removeGameObj" ref="8fa0a2e6fea2a7f1c9c88164818eda26" args="(GameObj *obj, bool deleteIt, int srcLayer=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::removeGameObj           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>deleteIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcLayer</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> for the specified <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code> and removes it from its current layer. 
<p>
If the <code>deleteIt</code> parameter is true, the object will also be <code>delete</code>d.<p>
If a valid source layer is specified, it is used to trim down the search. (If you already know which layer the object is in, you can get a performance boost by telling the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> where to look. Rather than inspecting <em>all</em> the layers, only <code>srcLayer</code> is searched.)<p>
This operation is buffered, and its effects will only be "visible" in the next frame. (This includes the object's <code>delet</code>ion.)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#06ab1091a54083d7d2f884a608a1d9c1">addGameObj()</a>, <a class="el" href="classqaf_1_1_environment.html#5f90f160ccab9952a6f4093a881728cc">moveGameObj()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f90f160ccab9952a6f4093a881728cc"></a><!-- doxytag: member="qaf::Environment::moveGameObj" ref="5f90f160ccab9952a6f4093a881728cc" args="(GameObj *obj, int destLayer, int srcLayer=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::moveGameObj           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>destLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcLayer</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> for the specified <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>, removes it from its current layer and places it into the destination layer. 
<p>
The object will be at the frontmost position in that layer.<p>
If a valid source layer is specified, it is used to trim down the search. (If you already know which layer the object is in, you can get a performance boost by telling the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> where to look. Rather than inspecting <em>all</em> the layers, only <code>srcLayer</code> is searched.)<p>
If <code>destLayer</code> is not a valid layer index, the object will be inserted in the loaded room's default object layer.<p>
This operation is buffered, and its effects will only be "visible" in the next frame.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#06ab1091a54083d7d2f884a608a1d9c1">addGameObj()</a>, <a class="el" href="classqaf_1_1_environment.html#8fa0a2e6fea2a7f1c9c88164818eda26">removeGameObj()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7bff52cbed5afedd9369de89ef1c2b1a"></a><!-- doxytag: member="qaf::Environment::bringGameObjToFront" ref="7bff52cbed5afedd9369de89ef1c2b1a" args="(GameObj *obj, int srcLayer=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::bringGameObjToFront           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcLayer</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brings the object to the front of its layer. 
<p>
The object will be updated and rendered after all others in its layer. Thus, it will appear "on top" of everything.<p>
This does <em>not</em> move the object to another layer. It simply changes its position in-layer.<p>
This operation is buffered, and its effects are not immediately visible.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#5806ba08a266344d6ca59a064ba70bfa">sendGameObjToBack()</a>, <a class="el" href="classqaf_1_1_environment.html#5f90f160ccab9952a6f4093a881728cc">moveGameObj()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5806ba08a266344d6ca59a064ba70bfa"></a><!-- doxytag: member="qaf::Environment::sendGameObjToBack" ref="5806ba08a266344d6ca59a064ba70bfa" args="(GameObj *obj, int srcLayer=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::sendGameObjToBack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcLayer</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends the object to the back of its layer. 
<p>
The object will be updated and rendered before all others in its layer. Thus, it will appear "below" everything.<p>
This does <em>not</em> move the object to another layer. It simply changes its position in-layer.<p>
This operation is buffered, and its effects are not immediately visible.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#7bff52cbed5afedd9369de89ef1c2b1a">bringGameObjToFront()</a>, <a class="el" href="classqaf_1_1_environment.html#5f90f160ccab9952a6f4093a881728cc">moveGameObj()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c9ae9c8bb980fd4d53ba50924a8e371"></a><!-- doxytag: member="qaf::Environment::getNumberOfJoysticks" ref="6c9ae9c8bb980fd4d53ba50924a8e371" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int qaf::Environment::getNumberOfJoysticks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of joysticks that are currently available. </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#9ea649952f5347b7a83e7b84ecd05091">getJoystick()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ea649952f5347b7a83e7b84ecd05091"></a><!-- doxytag: member="qaf::Environment::getJoystick" ref="9ea649952f5347b7a83e7b84ecd05091" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classqaf_1_1_joystick.html">Joystick</a>* qaf::Environment::getJoystick           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <code><a class="el" href="classqaf_1_1_joystick.html">Joystick</a></code> device available at index <code>i</code>, or <code>NULL</code> if an invalid index is specified. </dd></dl>

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#6c9ae9c8bb980fd4d53ba50924a8e371">getNumberOfJoysticks()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e4e3e2723c52ffee3792299de9c93fbf"></a><!-- doxytag: member="qaf::Environment::loadBigTexture" ref="e4e3e2723c52ffee3792299de9c93fbf" args="(const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a>* qaf::Environment::loadBigTexture           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a <code><a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a></code> from a file on the disk. 
<p>
The <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> maintains a cache of loaded textures, so as to avoid the duplication of these objects. If the texture has already been loaded, a pointer to it will be returned instead of creating a new texture.<p>
Do not <code>delete</code> this pointer. When you no longer need the texture, release it by calling <code><a class="el" href="classqaf_1_1_environment.html#f245b7efc1bad945a935bfbe8d5981c8">Environment::freeBigTexture()</a></code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#f245b7efc1bad945a935bfbe8d5981c8">Environment::freeBigTexture()</a>, <a class="el" href="classqaf_1_1_environment.html#353307336567f728fd84cb0474f35385">Environment::setBigTextureCacheSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f245b7efc1bad945a935bfbe8d5981c8"></a><!-- doxytag: member="qaf::Environment::freeBigTexture" ref="f245b7efc1bad945a935bfbe8d5981c8" args="(const BigTexture *tex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::freeBigTexture           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a> *&nbsp;</td>
          <td class="paramname"> <em>tex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases an allocated <code><a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a></code>. 
<p>
The texture must have been loaded with the <code><a class="el" href="classqaf_1_1_environment.html#e4e3e2723c52ffee3792299de9c93fbf">Environment::loadBigTexture()</a></code> method. The texture's reference counter will be decremented, but it will not be removed immediately.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_environment.html#e4e3e2723c52ffee3792299de9c93fbf">Environment::loadBigTexture()</a>, <a class="el" href="classqaf_1_1_environment.html#353307336567f728fd84cb0474f35385">Environment::setBigTextureCacheSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="353307336567f728fd84cb0474f35385"></a><!-- doxytag: member="qaf::Environment::setBigTextureCacheSize" ref="353307336567f728fd84cb0474f35385" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::setBigTextureCacheSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coordinates the <code><a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a></code> cache management. 
<p>
When a <code><a class="el" href="classqaf_1_1_big_texture.html">BigTexture</a></code>'s reference counter reaches zero, it is not deleted immediately, but is kept in the cache until all slots have been filled.<p>
When a new texture is requested with <code><a class="el" href="classqaf_1_1_environment.html#e4e3e2723c52ffee3792299de9c93fbf">loadBigTexture()</a></code>, the least-recently-freed texture will be <code>deleted</code> to make room for the new object.<p>
You can control how many slots are available in the cache with this method. The default initial value is 7.<p>
If <code>size</code> is less or equal to zero, the method does nothing. 
</div>
</div><p>
<a class="anchor" name="e2def878a51909ef17e4573b6394d26a"></a><!-- doxytag: member="qaf::Environment::makeObjIterator" ref="e2def878a51909ef17e4573b6394d26a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classqaf_1_1_obj_iterator.html">ObjIterator</a>&lt;T&gt; qaf::Environment::makeObjIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows clients to traverse the active object list. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If you need to iterate over the object list, get a new iterator every frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_obj_iterator.html">ObjIterator</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="720039cb11d774d4e316722320eb5bf3"></a><!-- doxytag: member="qaf::Environment::registerCollisionHandler" ref="720039cb11d774d4e316722320eb5bf3" args="(void(*pfHandler)(T1 *, T2 *))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void qaf::Environment::registerCollisionHandler           </td>
          <td>(</td>
          <td class="paramtype">void(*)(T1 *, T2 *)&nbsp;</td>
          <td class="paramname"> <em>pfHandler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a collision handler between classes of objects. 
<p>
In the template's two typenames, you specify two subclasses of <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code> to test for collisions. Every frame, all active instances of these two classes will be tested against each other for collisions, and the handler function will be invoked.<p>
For instance, let's say you have created the classes <code>PlayerObj</code> and <code>EnemyObj</code>, both subclasses of <code><a class="el" href="classqaf_1_1_game_obj.html">GameObj</a></code>:<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// This is the collision handler. It will be called every time the</span>
    <span class="comment">// player touches an enemy.</span>
    <span class="keywordtype">void</span> handler_PlayerEnemy ( PlayerObj * p, EnemyObj * e ) {
        <span class="comment">// Get the enemy's damage strength:</span>
        <span class="keywordtype">int</span> enemyDamage = e-&gt;getDamageStrength();
        
        <span class="comment">// "Hurt" the player:</span>
        p-&gt;decreaseHP( enemyDamage );
    };
</pre></div> <div class="fragment"><pre class="fragment">    <span class="comment">// Now, somewhere in main()...</span>
    <span class="comment">// Tell the environment that collisions between PlayerObj and</span>
    <span class="comment">// EnemyObj are handled by the handler_PlayerEnemy function:</span>
    Environment::registerCollisionHandler&lt;PlayerObj, EnemyObj&gt; ( handler_PlayerEnemy );
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfHandler</em>&nbsp;</td><td>The handler function to be invoked when a collision occurs. It will receive the two colliding objects as its two parameters. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="62d38ac3354cb61971c5abe88509e8bc"></a><!-- doxytag: member="qaf::Environment::time" ref="62d38ac3354cb61971c5abe88509e8bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classqaf_1_1_environment.html#62d38ac3354cb61971c5abe88509e8bc">qaf::Environment::time</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A "clock" used by the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> to update the water level's undulation, current, and refraction. 
<p>
This value is kept consistent with the <code>dt</code> parameter supplied to <code><a class="el" href="classqaf_1_1_environment.html#bad0c6b9a7110806673e639aeff788d9">update()</a></code>.<p>
This field may be modified at will; for instance, you could reset the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> time by setting <code>time = 0</code>. 
</div>
</div><p>
<a class="anchor" name="70e73860c328e85b995513f3df534cb8"></a><!-- doxytag: member="qaf::Environment::debugVectors" ref="70e73860c328e85b995513f3df534cb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqaf_1_1_container.html">Container</a>&lt;<a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a>&gt; <a class="el" href="classqaf_1_1_environment.html#70e73860c328e85b995513f3df534cb8">qaf::Environment::debugVectors</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add <code><a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a></code>s here. 
<p>
This container will be checked at the end of every frame, and its contents will be rendered as described in the <code><a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a></code> class.<p>
Once that's done, the container will be automatically emptied in preparation for the next frame.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a></dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><code><a class="el" href="classqaf_1_1_debug_vector.html">DebugVector</a></code>s are only available if you initialize the <code><a class="el" href="classqaf_1_1_environment.html">Environment</a></code> with <code>useDebug</code> set to true. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="qaf_environment_8h-source.html">qafEnvironment.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Mar 25 12:32:14 2007 for Qaf Framework by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
